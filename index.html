<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FPS Híbrido con Joystick y Three.js</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        
        /* Zona del Joystick (para NippleJS) */
        #joystick-zone {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 150px;
            height: 150px;
            z-index: 100;
        }

        /* Instrucciones para PC/Look */
        #instructions {
            position: absolute; 
            top: 0; 
            width: 100%; 
            text-align: center; 
            color: white; 
            background-color: rgba(0,0,0,0.7); 
            padding: 10px; 
            z-index: 99;
            font-family: sans-serif;
        }
    </style>
</head>
<body>
    <div id="joystick-zone"></div>

    <div id="instructions">Usa el ratón/tacto para mirar, Joystick para mover.</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script> 
    <script src="https://unpkg.com/three@0.137.0/examples/js/loaders/RGBELoader.js"></script>
    <script src="https://unpkg.com/three@0.137.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/nipplejs@0.9.0/dist/nipplejs.min.js"></script>

    <script>
        // =========================================================
        // THREE.JS: FPS HÍBRIDO CON JOYSTICK (NippleJS) Y ORBITCONTROLS
        // =========================================================

        // Variables de escena y control
        let hdrTexture = null;
        let controls;
        let prevTime = performance.now(); 
        
        // Variables de movimiento para Joystick
        let moveXJoystick = 0;
        let moveZJoystick = 0;
        const speed = 15.0; 

        // Vectores auxiliares para el cálculo de la dirección
        const direction = new THREE.Vector3();
        const velocity = new THREE.Vector3();
        const sideDirection = new THREE.Vector3();


        // === 1. PILARES FUNDAMENTALES ===
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.y = 1.6; // Altura de los ojos

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);


        // === 2. CONTROLES: ORBITCONTROLS (LOOK) ===
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.enableZoom = false; // Deshabilitar zoom para FPS
        controls.enablePan = false;  // Deshabilitar paneo
        controls.maxPolarAngle = Math.PI / 2; // Evita mirar debajo del horizonte

        // Target inicial: un punto justo delante de la cámara
        controls.target.set(camera.position.x, camera.position.y, camera.position.z - 0.1); 

        // Ocultar instrucciones al primer clic/toque
        document.getElementById('instructions').addEventListener('click', () => {
            document.getElementById('instructions').style.display = 'none';
        });


        // === 3. JOYSTICK VIRTUAL (NippleJS) ===
        const joystick = nipplejs.create({
            zone: document.getElementById('joystick-zone'),
            mode: 'static',
            position: { left: '50%', bottom: '50%' },
            color: 'white',
            size: 100
        });

        joystick.on('move', (evt, data) => {
            if (data && data.vector) {
                // El vector X y Z se guardan directamente para usar en la animación
                moveXJoystick = data.vector.x;
                moveZJoystick = data.vector.y; 
            }
        });

        joystick.on('end', () => {
            moveXJoystick = 0;
            moveZJoystick = 0;
        });


        // === 4. OBJETO Y ENTORNO (HDR) ===
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            metalness: 0.9,
            roughness: 0.2
        });
        const cube = new THREE.Mesh(geometry, material);
        cube.position.set(0, 0.5, -5); 
        scene.add(cube);

        const loader = new THREE.RGBELoader();
        // NOTA: El archivo .hdr debe estar en la misma carpeta que este HTML
        loader.load('citrus_orchard_road_puresky_4k.hdr', (texture) => {
            hdrTexture = texture; 
            hdrTexture.mapping = THREE.EquirectangularReflectionMapping;
            scene.environment = hdrTexture;
            scene.background = hdrTexture;
            material.needsUpdate = true;
        });


        // === 5. BUCLE DE RENDERIZADO Y ANIMACIÓN ===
        function animate() {
            requestAnimationFrame(animate);
            
            const time = performance.now();
            const delta = (time - prevTime) / 1000;

            // 1. LÓGICA DE MOVIMIENTO (Joystick)
            if (moveXJoystick !== 0 || moveZJoystick !== 0) {
                
                // Reiniciar y aplicar velocidad desde el joystick
                velocity.set(moveXJoystick, 0, -moveZJoystick); 
                velocity.normalize().multiplyScalar(speed * delta);

                // Obtener la dirección a la que apunta la cámara (horizontal)
                camera.getWorldDirection(direction); 
                direction.y = 0; 
                direction.normalize(); 

                // Obtener la dirección lateral (perpendicular al avance)
                sideDirection.copy(direction).cross(camera.up); 
                
                // Aplicar el movimiento a la posición de la cámara:
                // Avance/Retroceso: Usamos la componente Z del joystick (velocity.z)
                camera.position.addScaledVector(direction, velocity.z);
                // Lateral: Usamos la componente X del joystick (velocity.x)
                camera.position.addScaledVector(sideDirection, velocity.x);
            }
            
            // 2. LÓGICA DE ROTACIÓN (Look)
            
            // Mover el target de OrbitControls con la cámara (para que rote sobre sí misma)
            controls.target.copy(camera.position);
            controls.target.y += 0.001; 
            
            // Actualizar controles. Esto procesa el movimiento del ratón/tacto.
            controls.update(); 
            
            // Animaciones
            cube.rotation.y += 0.005;
            if (hdrTexture) {
                hdrTexture.offset.x += 0.0001;
            }

            prevTime = time;
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>